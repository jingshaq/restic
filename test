use rust_fsm::*;


#[derive(Clone, Debug, PartialEq)]
enum SyncInput {
    StartSync,
    SectorSynced,
    VolumeSynced,
}


#[derive(Clone, Debug, PartialEq)]
enum SyncOutput {
    SyncingSector(u32),
    SyncingVolume(u32),
    SyncComplete,
}


struct SyncStateMachine {
    diskc_bitmap: DiskcBitmap,
}


struct DiskcBitmap {
    bms_count: u32,
    bms_index: u32,
    volgroups: Vec<VolGroup>,
}


struct VolGroup {
    start: u32,
    end: u32,
    index: u32,
}

impl StateMachineImpl for SyncStateMachine {
    type Input = SyncInput;
    type State = ();
    type Output = Option<SyncOutput>;

    fn transition(
        &mut self,
        _state: Self::State,
        input: &Self::Input,
    ) -> (Self::State, Self::Output) {
        match input {
            SyncInput::StartSync => {
                let volgroup = &self.diskc_bitmap.volgroups[self.diskc_bitmap.bms_index as usize];
                let sector_index = volgroup.index;
                ((), Some(SyncOutput::SyncingSector(sector_index)))
            }
            SyncInput::SectorSynced => {
                let volgroup =
                    &mut self.diskc_bitmap.volgroups[self.diskc_bitmap.bms_index as usize];
                volgroup.index += 1;
                if volgroup.index > volgroup.end {
                    ((), Some(SyncOutput::VolumeSynced(self.diskc_bitmap.bms_index)))
                } else {
                    let sector_index = volgroup.index;
                    ((), Some(SyncOutput::SyncingSector(sector_index)))
                }
            }
            SyncInput::VolumeSynced => {
                self.diskc_bitmap.bms_index += 1;
                if self.diskc_bitmap.bms_index >= self.diskc_bitmap.bms_count {
                    ((), Some(SyncOutput::SyncComplete))
                } else {
                    let volgroup =
                        &self.diskc_bitmap.volgroups[self.diskc_bitmap.bms_index as usize];
                    let sector_index = volgroup.index;
                    ((), Some(SyncOutput::SyncingSector(sector_index)))
                }
            }
        }
    }

    fn is_final_state(&self, _state: &Self::State) -> bool {
        false
    }
}


let diskc_bitmap = DiskcBitmap {
    bms_count: 2,
    bms_index: 0,
    volgroups: vec![
        VolGroup {
            start: 0,
            end: 1,
            index: 0,
        },
        VolGroup {
            start: 0,
            end: 1,
            index: 0,
        },
    ],
};
let mut machine = StateMachine::new_with_state(SyncStateMachine { diskc_bitmap }, ());

let output = machine.consume(&SyncInput::StartSync);
assert_eq!(output, Some(SyncOutput::SyncingSector(0)));

let output = machine.consume(&SyncInput::SectorSynced);
assert_eq!(output, Some(SyncOutput::VolumeSynced(0)));

let output = machine.consume(&SyncInput::VolumeSynced);
assert_eq!(output, Some(SyncOutput::SyncingSector(0)));

let output = machine.consume(&SyncInput::SectorSynced);
assert_eq!(output, Some(SyncOutput::VolumeSynced(1)));

let output = machine.consume(&SyncInput::VolumeSynced);
assert_eq!(output, Some(SyncOutput::SyncComplete));
